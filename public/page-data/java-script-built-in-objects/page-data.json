{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/java-script-built-in-objects",
    "result": {"data":{"strapiArticles":{"id":"Articles_530","title":"JavaScript的内置对象","description":"JavaScript中的所以内置对象及其详细用法。","content":"##### 一、值属性\n\n###### 1、Infinity\n\n全局属性，表示无穷大，初始值为 Number.POSITIVE_INFINITY\n\n```js\nconst maxNumber = Math.pow(10, 1000); // max positive number\n\nif (maxNumber === Infinity) {\n  console.log('Let\\'s call it Infinity!');\n  // expected output: \"Let's call it Infinity!\"\n}\n\nconsole.log(1 / maxNumber);\n// expected output: 0\n```\n\n---\n\n###### 2、NaN\n\n全局属性，表示不是一个数字（Not-A-Number）。\n\n```js\nfunction sanitise(x) {\n  if (isNaN(x)) {\n    return NaN;\n  }\n  return x;\n}\n\nconsole.log(sanitise('1'));\n// expected output: \"1\"\n\nconsole.log(sanitise('NotANumber'));\n// expected output: NaN\n```\n\n---\n\n###### 3、undefined\n\n全局属性，表示未定义。\n\n```js\nfunction test(t) {\n  if (t === undefined) {\n    return 'Undefined value!';\n  }\n  return t;\n}\n\nlet x;\n\nconsole.log(test(x));\n// expected output: \"Undefined value!\"\n```\n\n---\n\n###### 4、globalThis\n\n不同的 JavaScript 环境中获取全局对象需要不同的语句。在 Web 中，可以通过 window、self 或者 frames 取到全局对象，但是在 Web Workers 中，只有 self 可以。在 Node.js 中，它们都无法获取，必须使用 global。\n\nglobalThis 提供了一个标准的方式来获取不同环境下的全局 this  对象（也就是全局对象自身）。不像 window 或者 self 这些属性，它确保可以在有无窗口的各种环境下正常工作。所以，你可以安心的使用 globalThis，不必担心它的运行环境。为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。[更多内容，看这里！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/globalThis)\n\n```js\nfunction canMakeHTTPRequest() {\n  return typeof globalThis.XMLHttpRequest === 'function';\n}\n\nconsole.log(canMakeHTTPRequest());\n// expected output (in a browser): true\n```\n\n---\n\n##### 二、函数属性\n\n###### 1、eval()\n\n全局函数，将传入的字符串当做 JavaScript 代码进行执行。\n\n```js\nconsole.log(eval('2 + 2'));\n// expected output: 4\n\nconsole.log(eval(new String('2 + 2')));\n// expected output: 2 + 2\n\nconsole.log(eval('2 + 2') === eval('4'));\n// expected output: true\n\nconsole.log(eval('2 + 2') === eval(new String('2 + 2')));\n// expected output: false\n```\n\n---\n\n###### 2、isFinite()\n\n全局函数，可以用这个方法来判定一个数字是否是有限数字。\n\n```js\nfunction div(x) {\n  if (isFinite(1000 / x)) {\n    return 'Number is NOT Infinity.';\n  }\n  return 'Number is Infinity!';\n}\n\nconsole.log(div(0));\n// expected output: \"Number is Infinity!\"\"\n\nconsole.log(div(1));\n// expected output: \"Number is NOT Infinity.\"\n```\n\n---\n\n###### 3、isNaN()\n\n全局函数，用来确定一个值是否为 NaN.\n\n```js\nfunction milliseconds(x) {\n  if (isNaN(x)) {\n    return 'Not a Number!';\n  }\n  return x * 1000;\n}\n\nconsole.log(milliseconds('100F'));\n// expected output: \"Not a Number!\"\n\nconsole.log(milliseconds('0.0314E+2'));\n// expected output: 3140\n```\n\n---\n\n###### 4、parseFloat()\n\n全局函数，转换参数为浮点数。\n\n```js\nfunction circumference(r) {\n  return parseFloat(r) * 2.0 * Math.PI;\n}\n\nconsole.log(circumference(4.567));\n// expected output: 28.695307297889173\n\nconsole.log(circumference('4.567abcdefgh'));\n// expected output: 28.695307297889173\n\nconsole.log(circumference('abcdefgh'));\n// expected output: NaN\n```\n\n---\n\n###### 5、parseInt()\n\n全局函数，转换为整数（十进制）。\n\n```js\nfunction roughScale(x, base) {\n  const parsed = parseInt(x, base);\n  if (isNaN(parsed)) { return 0; }\n  return parsed * 100;\n}\n\nconsole.log(roughScale(' 0xF', 16));\n// expected output: 1500\n\nconsole.log(roughScale('321', 2));\n// expected output: 0\n```\n\n---\n\n###### 6、encodeURI()\n\n将 URI 进行转义，但不包括一些特殊字符：`;` `,` `/` `?` `:` `@` `&` `=` `+` `$` 等。\n\n```js\nfunction fixedEncodeURI (str) {\n    return encodeURI(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\n```\n\n---\n\n###### 7、encodeURIComponent()\n\n对 URI 中的特殊字符进行转义，使其能正常应用在 http请求中，同时也可避免一些恶意参数。\n\n```js\n// encodes characters such as ?,=,/,&,:\nconsole.log(`?x=${encodeURIComponent('test?')}`);\n// expected output: \"?x=test%3F\"\n\nconsole.log(`?x=${encodeURIComponent('шеллы')}`);\n// expected output: \"?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\"\n```\n\n---\n\n###### 8、decodeURI()\n\n解码由encodeURI 创建或其它流程得到的统一资源标识符（URI）。\n\n```js\nconst uri = 'https://mozilla.org/?x=шеллы';\nconst encoded = encodeURI(uri);\nconsole.log(encoded);\n// expected output: \"https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B\"\n\ntry {\n  console.log(decodeURI(encoded));\n  // expected output: \"https://mozilla.org/?x=шеллы\"\n} catch (e) { // catches a malformed URI\n  console.error(e);\n}\n```\n\n---\n\n###### 9、decodeURIComponent()\n\n用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）。\n\n```js\ntry {\n  var a = decodeURIComponent('%E0%A4%A');\n} catch(e) {\n  console.error(e);\n}\n\n// URIError: malformed URI sequence\n```\n\n---\n\n##### 三、内置对象\n\n###### 1、Object\n\nObject 是 JavaScript 的一种 数据类型 ，用于存储各种键值集合和更复杂的实体，几乎所有对象都是  `Object`  类型的实例，它们都会从  `Object.prototype`  继承属性和方法，虽然大部分属性都会被覆盖（shadowed）或者说被重写了（overridden）。\n\n一个对象就是一系列属性的集合，属性包括名字和值。如果属性值是函数，那么称之为方法。[详细内容，看这里！](https://learn-anything.cn/java-script-object)\n\n---\n\n###### 2、Function\n\n由 `function关键字`、函数名称和一些语句组成的函数体称之为函数。在 JavaScript中，函数与其他对象一样具有属性和方法，区别是函数可以被调用。如果一个函数中没有使用return语句，则它默认返回 `undefined`。[详细内容，看这里！](https://learn-anything.cn/java-script-function)\n\n---\n\n###### 3、Boolean\n\nbool 是表示 true 或 false 的基础数据类型。Boolean 是表示 true 或 false 的对象数据类型，可以把其他类型转换为 Boolean 类型。[更多内容，看这里！](https://learn-anything.cn/java-script-boolean)\n\n---\n\n###### 4、Symbol\n\nSymbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突。[详细内容，看这里！](https://learn-anything.cn/java-script-symbol)\n\n---\n\n##### 四、错误对象\n\n###### 1、Error\n\n当运行时错误产生时，Error的实例对象会被抛出。Error对象也可用于用户自定义的异常的基础对象。\n\n```js\n// Error 使用方法\ntry {\n    throw new Error(\"Whoops!\");\n} catch (e) {\n    if (e instanceof EvalError) {\n        alert(e.name + \": \" + e.message);\n    } else if (e instanceof RangeError) {\n        alert(e.name + \": \" + e.message);\n    }\n    // ... etc\n}\n```\n\n```js\n// 自定义 Error\nfunction MyError(message) {\n  this.name = 'MyError';\n  this.message = message || 'Default Message';\n  this.stack = (new Error()).stack;\n}\nMyError.prototype = Object.create(Error.prototype);\nMyError.prototype.constructor = MyError;\n\ntry {\n  throw new MyError('custom message');\n} catch (e) {\n  console.log(e.name);     // 'MyError'\n  console.log(e.message);  // 'custom message'\n}\n```\n\n---\n\n###### 2、EvalError\n\n表示 eval 函数的错误。\n\n```js\ntry {\n  throw new EvalError('Hello', 'someFile.js', 10);\n} catch (e) {\n  console.log(e instanceof EvalError); // true\n  console.log(e.message);              // \"Hello\"\n  console.log(e.name);                 // \"EvalError\"\n  console.log(e.fileName);             // \"someFile.js\"\n  console.log(e.lineNumber);           // 10\n  console.log(e.columnNumber);         // 0\n  console.log(e.stack);                // \"@Scratchpad/2:2:9\\n\"\n}\n```\n\n---\n\n###### 3、RangeError\n\n表示一个值超出了范围的错误\n\n```js\nvar check = function(num) {\n  if (num < MIN || num > MAX) {\n    throw new RangeError('Parameter must be between ' + MIN + ' and ' + MAX);\n  }\n};\n\ntry {\n  check(500);\n}\ncatch (e) {\n  if (e instanceof RangeError) {\n    // 处理越界错误\n  }\n}\n```\n\n---\n\n###### 4、ReferenceError\n\n表示引用不存在变量的错误。\n\n```js\ntry {\n  throw new ReferenceError('Hello', 'someFile.js', 10);\n} catch (e) {\n  console.log(e instanceof ReferenceError); // true\n  console.log(e.message);                   // \"Hello\"\n  console.log(e.name);                      // \"ReferenceError\"\n  console.log(e.fileName);                  // \"someFile.js\"\n  console.log(e.lineNumber);                // 10\n  console.log(e.columnNumber);              // 0\n  console.log(e.stack);                     // \"@Scratchpad/2:2:9\\n\"\n}\n```\n\n---\n\n###### 5、SyntaxError\n\n表示语法错误。\n\n```js\ntry {\n  throw new SyntaxError('Hello', 'someFile.js', 10);\n} catch (e) {\n  console.log(e instanceof SyntaxError); // true\n  console.log(e.message);                // \"Hello\"\n  console.log(e.name);                   // \"SyntaxError\"\n  console.log(e.fileName);               // \"someFile.js\"\n  console.log(e.lineNumber);             // 10\n  console.log(e.columnNumber);           // 0\n  console.log(e.stack);                  // \"@Scratchpad/2:11:9\\n\"\n}\n```\n\n---\n\n###### 6、TypeError\n\n表示值类型不匹配时的错误。\n\n```js\ntry {\n  throw new TypeError('Hello', \"someFile.js\", 10);\n} catch (e) {\n  console.log(e instanceof TypeError); // true\n  console.log(e.message);              // \"Hello\"\n  console.log(e.name);                 // \"TypeError\"\n  console.log(e.fileName);             // \"someFile.js\"\n  console.log(e.lineNumber);           // 10\n  console.log(e.columnNumber);         // 0\n  console.log(e.stack);                // \"@Scratchpad/2:2:9\\n\"\n}\n```\n\n---\n\n##### 五、数字和日期对象\n\n###### 1、Date\n\n自1970年1月1日（UTC）起经过的毫秒数。[更多内容，看这里！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)\n\n```html\n<!DOCTYPE html>\n<html lang='zh-CN'>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Symbol</title>\n    <script>\n        // 获取当前时间\n        console.log(Date());\n        console.log(new Date().toLocaleTimeString());\n        console.log(new Date().toLocaleDateString());\n        console.log(new Date().toLocaleString());\n        console.log(Date.now());\n        console.log(new Date('December 17, 1995 03:24:00'));\n    </script>\n</head>\n\n<body>\n    <h1>Symbol : 打开 Console 看结果！</h1>\n</body>\n\n</html>\n```\n\n---\n\n###### 2、Number\n\n将其他类型转换为数字类型。\n\n```html\n<!DOCTYPE html>\n<html lang='zh-CN'>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Symbol</title>\n    <script>\n        var biggestNum = Number.MAX_VALUE;\n        var smallestNum = Number.MIN_VALUE;\n        var infiniteNum = Number.POSITIVE_INFINITY;\n        var negInfiniteNum = Number.NEGATIVE_INFINITY;\n        var notANum = Number.NaN;\n        var biggestInt = Number.MAX_SAFE_INTEGER;\n        var smallestInt = Number.MIN_SAFE_INTEGER;\n\n        console.log(Number('foo'));      // NaN\n        console.log(Number('100a'));      // NaN\n    </script>\n</head>\n\n<body>\n    <h1>Symbol : 打开 Console 看结果！</h1>\n</body>\n\n</html>\n```\n\n---\n\n###### 3、BigInt\n\n在一个整数字面量后面加 `n` 的方式定义一个 `BigInt`，表示任意大的整数 。[更多内容，看这里！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt)\n\n```js\nconst previousMaxSafe = BigInt(Number.MAX_SAFE_INTEGER);\n// ↪ 9007199254740991n\n\nconst maxPlusOne = previousMaxSafe + 1n;\n// ↪ 9007199254740992n\n```\n\n---\n\n###### 4、Math\n\n提供一些数学常数和数学函数方法。[更多内容，看这里！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math)\n\n---\n\n##### 六、字符串\n\n###### 1、String\n\n将其他值转换成字符串。JavaScript会自动将基本字符串转换为String对象，这样才能使用String对象的方法。[更多方法，看这里！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)\n\n---\n\n###### 2、RegExp(正则表达式)\n\n正则表达式是用于匹配字符串的语法。在 JavaScript中，被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。[详细用法，看这里！](https://learn-anything.cn/java-script-regexp)\n\n---\n\n##### 七、复杂对象\n\n###### 1、数组对象\n\n- [Array](https://learn-anything.cn/java-script-array) ：全局数组对象，其元素可以是不同类型，如果需要元素是同一类型，可使用 TypedArray。\n\n###### 2、键值对象\n\n- [Map](https://learn-anything.cn/java-script-map) ：是键/值对的集合。\n\n- [Set](https://learn-anything.cn/java-script-set) ：一组对象的集合且能保证对象的唯一性。\n\n- [WeakMap](https://learn-anything.cn/java-script-weak-map) ：是键/值对的集合，键必须是 `Object` 类型，值可以是任意类型，当没有地方引用键所指对象时，它会被 GC 回收，因此 WeakMap 键值是无法预知的，由垃圾回收器(GC)决定。\n\n- [WeakSet](https://learn-anything.cn/java-script-weak-set)  ：对象是一组对象的集合，对象不重复且不可枚举。WeakSet中的对象，如果不存在其他引用，那么该对象将可被垃圾回收，不用担心内存泄露。\n\n###### 3、结构化数据\n\n- [ArrayBuffer](https://learn-anything.cn/java-script-array) ：对象用来表示通用的、固定长度的原始二进制数据缓冲区。\n\n- [DataView](https://learn-anything.cn/java-script-array) ：可以从 二进制ArrayBuffer 对象中读写多种数值类型的底层接口，使用它时，不用考虑不同平台的字节序问题。\n\n- [SharedArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) ：对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。\n- [Atomics](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics) ： 提供了一组静态方法对 SharedArrayBuffer 和  ArrayBuffer 对象进行原子操作。\n\n- [JSON](https://learn-anything.cn/java-script-json) ：一种语法，是一种完全独立于编程语言的文本格式。可以把  `任意编程语言表示的数据类型` 转换成 `JSON格式的字符串`，也可以反向转换。这样不同编程语言，就可以通过 JSON 格式来共享数据。\n\n###### 4、抽象对象\n\n- [Promise](https://learn-anything.cn/javascript-promise) ：用于绑定异步操作与回调函数的对象，让代码更易读且更合理。\n\n- [Generator](https://learn-anything.cn/java-script-generator) ：不能直接实例化，只能由生成器函数返回生成，具有迭代功能。\n- [GeneratorFunction](https://learn-anything.cn/java-script-function-create) ：创建的生成器函数。\n- [AsyncFunction](https://learn-anything.cn/java-script-function) ：动态创建异步函数。\n\n###### 5、反射\n\n- [Reflect](https://learn-anything.cn/java-script-reflect) ：是全局对象但不是函数对象，不能用new操作，它所有属性和方法都是静态的。可对目标对象进行一些操作：调用一个函数，对构造函数进行new操作、获取对象的属性值等。\n\n- [Proxy](https://learn-anything.cn/java-script-proxy) ：全局对象，用于拦截并修改目标对象的指定操作。\n\n###### 6、其他\n\n- [Intl](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#%E5%9B%BD%E9%99%85%E5%8C%96)  ：ECMAScript核心的附加功能，用于支持多语言处理。\n\n- [WebAssembly](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#webassembly)  ：WebAssembly 有一套完整的语义，实际上 wasm 是体积小且加载快的二进制格式， 其目标就是充分发挥硬件能力以达到原生执行效率。\n\n---\n\n##### 八、参考文档\n\n- [JavaScript 标准内置对象 列表](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)\n\n\n","url":"https://learn-anything.cn/java-script-built-in-objects","published_at":"2021-12-26T04:06:59.000Z","tags":[{"name":"JavaScript","slug":"java-script"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"JavaScript的内置对象","slug":"java-script-built-in-objects"}},
    "staticQueryHashes": ["63159454"]}