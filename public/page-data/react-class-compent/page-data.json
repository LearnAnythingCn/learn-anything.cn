{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/react-class-compent",
    "result": {"data":{"strapiArticles":{"id":"Articles_117","title":"React的class组件及属性详解！","description":"生命周期方法有哪些？属性有哪些？怎么使用？挂载、更新、卸载、错误处理、强制更新等。props、state、setState、forceUpdate、componentDidMount、componentDidUpdate、componentWillUnmount、constructor。","content":"##### 一、class组件\n\nReact 有两种组件：class组件 和 函数组件。class组件需要继承 React.Component，用法如下：\n\n```jsx\nclass Welcome extends React.Component {\n    render() {\n        return <h1>Hello, {this.props.name}</h1>;\n    }\n}\n```\n\n###### 1、必须要重写的方法\n\n每一个继承  `React.Component`   的组件，都必须重写  `render()`  方法。\n\n###### 2、组合而非继承\n\nReact建议：不要创建自定义基类组件，使用组合而非继承的方式写组件。\n\n---\n\n##### 二、组件生命周期\n\n##### 1、方法运行图谱\n\n![React的组件生命周期](http://static.learn-anything.cn/react-com-life.png)\n\n---\n\n##### 2、挂载\n\n当组件实例被创建并插入 DOM 中时，调用顺序如下：\n\n###### - constructor()\n\n- 在组件挂载前被调用，使用方法及注意点如下：\n\n  ```js\n  constructor(props) {\n      // 1、一定要写这句，否则会出现  this.props  未定义bug。\n      super(props);\n  \n      // 2、构造函数是唯一能给state初始化的地方，但不要调用 this.setState() 赋值，\n      // 会触发render()方法，引起不必要的bug。\n      this.state = { counter: 0 };\n  \n      // 3、这里可以绑定组件的 事件处理函数\n      this.handleClick = this.handleClick.bind(this);\n  }\n  ```\n\n###### - static getDerivedStateFromProps()\n\n- 功能是：根据 props 的变化来更新 state。\n\n  ```js\n  // 初始挂载及后续更新时都会被调用，\n  static getDerivedStateFromProps(props, state)\n  ```\n\n###### - render()\n\n###### - componentDidMount()\n\n- 【调用】：会在组件挂载后（插入 DOM 树中）被调用；\n- 【使用】：适合于 `数据初始化操作`、   `网络请求获取数据操作` 。\n- 【注意】：这里调用 setState()，会触发render()，请谨慎使用，容易导致性能问题。\n\n---\n\n##### 3、更新\n\n当组件的 props 或 state 发生变化时会触发更新。调用顺序如下：\n\n###### - static getDerivedStateFromProps()\n\n- 功能是：根据 props 的变化来更新 state。\n\n  ```js\n  // 初始挂载及后续更新时都会被调用，\n  static getDerivedStateFromProps(props, state)\n  ```\n\n###### - shouldComponentUpdate()\n\n此方法仅用于性能优化。返回true，表示组件需要重新渲染；返回false，表示跳过渲染，默认返回值为 true。\n\n- 首次渲染或使用 forceUpdate() 时不会调用。\n\n- state 或 props 改变时，shouldComponentUpdate() 会在渲染执行之前被调用。\n- 不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。\n\n###### - render()\n\n###### - getSnapshotBeforeUpdate()\n\n- 在组件发生更改之前获取一些信息（譬如：滚动位置等），返回值将作为参数传递给 componentDidUpdate()\n\n  ```js\n  // 函数原型\n  getSnapshotBeforeUpdate(prevProps, prevState)\n  ```\n\n  ```jsx\n  // 使用实例\n  class ScrollingList extends React.Component {\n      constructor(props) {\n          super(props);\n          this.listRef = React.createRef();\n      }\n  \n      getSnapshotBeforeUpdate(prevProps, prevState) {\n          // 我们是否在 list 中添加新的 items ？\n          // 捕获滚动​​位置以便我们稍后调整滚动位置。\n          if (prevProps.list.length < this.props.list.length) {\n              const list = this.listRef.current;\n              return list.scrollHeight - list.scrollTop;\n          }\n          return null;\n      }\n  \n      componentDidUpdate(prevProps, prevState, snapshot) {\n          // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，\n          // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。\n          //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）\n          if (snapshot !== null) {\n              const list = this.listRef.current;\n              list.scrollTop = list.scrollHeight - snapshot;\n          }\n      }\n  \n      render() {\n          return (\n              <div ref={this.listRef}>{/* ...contents... */}</div>\n          );\n      }\n  }\n  ```\n\n---\n\n###### - componentDidUpdate()\n\n- 组件更新后会被调用，首次渲染不会执行此方法。\n\n- 可以执行一些自定义操作，譬如进行一些网络数据请求。\n\n  ```js\n  componentDidUpdate(prevProps) {\n      // 典型用法（不要忘记比较 props）：\n      if (this.props.userID !== prevProps.userID) {\n          this.fetchData(this.props.userID);\n      }\n  }\n  ```\n\n- 可以调用  setState()，但是一定要用条件语句包裹 setState()，否则渲染会进入死循环，因为setState会触发render()，render()后又会调用componentDidUpdate。请谨慎使用。\n\n- 如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。\n\n----\n\n##### 4、卸载\n\n###### - componentWillUnmount()\n\n- 当组件从 DOM 中移除时（卸载及销毁之前）调用。\n- 在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。\n\n---\n\n##### 5、错误处理\n\n当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：\n\n###### - static getDerivedStateFromError()\n\n- 在渲染阶段，后代组件抛出错误后被调用。\n\n  ```js\n  // 函数原型\n  static getDerivedStateFromError(error)\n  ```\n\n  ```jsx\n  // 使用示例\n  class ErrorBoundary extends React.Component {\n      constructor(props) {\n          super(props);\n          this.state = { hasError: false };\n      }\n  \n      static getDerivedStateFromError(error) {\n          // 更新 state 使下一次渲染显示自定义错误UI\n          return { hasError: true };\n      }\n  \n      render() {\n          if (this.state.hasError) {\n              // 你可以渲染任何自定义的  UI\n              return <h1>Something went wrong.</h1>;\n          }\n  \n          return this.props.children;\n      }\n  }\n  ```\n\n---\n\n###### - componentDidCatch()\n\n- // 后代组件抛出错误后被调用，可用于写错误日志\n\n  ```js\n  // 函数原型\n  componentDidCatch(error, info)\n  // error : 抛出的错误；\n  // info  : 错误的堆栈信息\n  ```\n\n  ```jsx\n  // 使用示例\n  class ErrorBoundary extends React.Component {\n      constructor(props) {\n          super(props);\n          this.state = { hasError: false };\n      }\n  \n      static getDerivedStateFromError(error) {\n          // 更新 state 使下一次渲染可以显示降级 UI\n          return { hasError: true };\n      }\n  \n      componentDidCatch(error, info) {\n          // \"组件堆栈\" 例子:\n          //   in ComponentThatThrows (created by App)\n          //   in ErrorBoundary (created by App)\n          //   in div (created by App)\n          //   in App\n          logComponentStackToMyService(info.componentStack);\n      }\n  \n      render() {\n          if (this.state.hasError) {\n              // 你可以渲染任何自定义的降级 UI\n              return <h1>Something went wrong.</h1>;\n          }\n  \n          return this.props.children;\n      }\n  }\n  ```\n\n---\n\n##### 6、属性\n\n###### - defaultProps\n\n- 为 props 添加默认值。\n\n  ```js\n  class CustomButton extends React.Component {\n      // ...\n  }\n  \n  CustomButton.defaultProps = {\n      color: 'blue'\n  };\n  ```\n\n  ```js\n  render() {\n      return <CustomButton />; // props.color 将设置为 'blue'\n  }\n  ```\n\n###### - displayName\n\n- 字符串类型，多用于调试消息。\n\n###### - props\n\n- 组件的内置属性，可用于组件间的属性数据传递。`this.props.children`  ：特指子组件。详细用法，[看这里！](https://learn-anything.cn/react-props)\n\n###### - state\n\n- 组件内置属性，它是一个普通 JavaScript 对象，用于组件内表示随时会发生变化的数据。详细用法，[看这里！](https://learn-anything.cn/react-state)\n\n---\n\n##### 7、其他\n\n###### - setState()\n\n- 函数原型\n\n  ```js\n  setState(updater, [callback])\n  ```\n\n- updater：如下两种使用方式\n\n  ```js\n  // 用函数方式：\n  this.setState((state, props) => {\n      return { counter: state.counter + props.step };\n  });\n  \n  // 用对象方式：\n  this.setState({ quantity: 2 })\n  ```\n\n- callback参数：  组件更新完成后进行的回调，不建议使用，应该把操作放在  componentDidUpdate()  中更合适。\n\n---\n\n###### - forceUpdate()\n\n- 强制调用 render() 进行重新渲染，会跳过  shouldComponentUpdate()，但其子组件会不会跳过。通常应该避免使用此方法。\n\n  ```js\n  // 函数原型\n  component.forceUpdate(callback)\n  ```\n\n---\n\n##### 三、参考链接：\n\n- [react-component](https://zh-hans.reactjs.org/docs/react-component.html)\n\n\n","url":"https://learn-anything.cn/react-class-compent","author":null,"published_at":"2021-10-14T09:37:25.000Z","tags":[{"name":"React","slug":"react"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"React的class组件及属性详解！","slug":"react-class-compent"}},
    "staticQueryHashes": ["63159454"]}