{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/react-hooks",
    "result": {"data":{"strapiArticles":{"id":"Articles_92","title":"React的Hook让函数组件拥有class组件的特性！","description":"useState与useEffect分别是啥？函数组件是啥？Hook是啥？怎么用？使用规则是啥？eslint-plugin-react-hooks插件是啥？State Hook，Effect Hook，自定义Hook，分别是啥？","content":"##### 一、解决了什么问题？\n\nHook 是以  `use`  开头的特殊函数（useState、useEffect等），只能在 函数组件  内部使用。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。譬如 useState 就等同于 class组件中的state对象。\n\n###### 1、库的更新说明\n\nHook是React 16.8 新增特性， 在以下模块中包含了 React Hook 的稳定实现：\n\n```\nReact DOM\nReact Native\nReact DOM Server\nReact Test Renderer\nReact Shallow Renderer\n\nReact Native 0.59 及以上版本支持 Hook。\n\n请注意，要启用 Hook，所有 React 相关的 package 都必须升级到 16.8.0 或更高版本。如果你忘记更新诸如 React DOM 之类的 package，Hook 将无法运行。\n```\n\n---\n\n##### 二、Hook 规则与插件\n\n###### 1、规则\n\n- Hook只能用在**React 的函数组件**和**自定义Hook**中。\n- Hook只能在**函数最外层**调用 ，在循环、条件判断或者子函数中调用都是不允许的。\n\n###### 2、插件\n\n`eslint-plugin-react-hooks`  用于检查Hook代码是否符合规则的插件。\n\n```shell\nnpm install eslint-plugin-react-hooks\n```\n\n###### 3、插件链接：\n\n- [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks) \n\n我们推荐启用 [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks#installation) 中的 [`exhaustive-deps`](https://github.com/facebook/react/issues/14920) 规则。此规则会在添加错误依赖时发出警告并给出修复建议。\n\n---\n\n##### 三、State Hook\n\nState Hook 就是指  `useState`  这个特殊函数，让你不用编写class，就可以使用state特性，换言之就是让  **函数组件**  拥有  state 特性。详细用法，[看这里！](https://learn-anything.cn/react-state-hook)\n\n---\n\n##### 四、Effect Hook\n\nEffect Hook 就是指  `useEffect` 这个特殊函数，它让  **函数组件**  能在组件渲染完成后执行自定义操作。详细用法，[看这里！](https://learn-anything.cn/react-effect-hook)\n\n---\n\n##### 五、自定义Hook\n\n自定义 Hook 是一个以  `use`  开头的自定义函数，其内部可以调用 Hook。\n\n###### 1、自定义Hook\n\n```js\nimport { useState, useEffect } from 'react';\n\nfunction useFriendStatus(friendID) {\n    const [isOnline, setIsOnline] = useState(null);\n\n    useEffect(() => {\n        function handleStatusChange(status) {\n            setIsOnline(status.isOnline);\n        }\n\n        ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n        return () => {\n            ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n        };\n    });\n\n    return isOnline;\n}\n```\n\n###### 2、使用自定义Hook\n\n```jsx\nconst friendList = [\n    { id: 1, name: 'Phoebe' },\n    { id: 2, name: 'Rachel' },\n    { id: 3, name: 'Ross' },\n];\n\nfunction ChatRecipientPicker() {\n    const [recipientID, setRecipientID] = useState(1);\n    const isRecipientOnline = useFriendStatus(recipientID);\n\n    return (\n        <>\n            <Circle color={isRecipientOnline ? 'green' : 'red'} />\n            <select\n                value={recipientID}\n                onChange={e => setRecipientID(Number(e.target.value))}\n            >\n                {friendList.map(friend => (\n                    <option key={friend.id} value={friend.id}>\n                        {friend.name}\n                    </option>\n                ))}\n            </select>\n        </>\n    );\n}\n```\n\n---\n\n##### 六、Context Hook\n\nContext Hook 就是指  `useContext`  这个特殊函数，解决了 props 在特殊场景下传递数据的烦恼。详细用法，[看这里！](https://learn-anything.cn/react-context)\n\n---\n\n##### 七、useReducer\n\nuseReducer  是 useState 的升级版本，对 setState 这个操作进行了拆分，可以根据不同类型，进行不同的逻辑计算，最后去改变 state 对象。详细用法，[看这里！](https://learn-anything.cn/react-reducer-hook)\n\n---\n\n##### 八、useLayoutEffect\n\nuseLayoutEffect  的使用与  useEffect  一样，只是被调用的时间点不同。useEffect 是在浏览器绘制完成后被调用，useLayoutEffect 在浏览器绘制前被调用。\n\n---\n\n##### 九、useDebugValue\n\n在 React 开发者工具中显示自定义 hook 的标签。\n\n```js\nfunction useFriendStatus(friendID) {\n    const [isOnline, setIsOnline] = useState(null);\n\n    // 在开发者工具中的这个 Hook 旁边显示标签\n    // e.g. \"FriendStatus: Online\"\n    useDebugValue(isOnline ? 'Online' : 'Offline');\n\n    return isOnline;\n}\n\n// 第二个参数可以增加调试输出信息\nuseDebugValue(date, date => date.toDateString());\n```\n\n---\n\n##### 十、useCallback\n\n设置一个回调函数，只有当依赖项的数值改变时，回调函数才被调用。如下，只有依赖项数组  `[a,b]`  有变动时，才会调用箭头函数。性能优化时，去除一些非必要的组件渲染。\n\n```js\nconst memoizedCallback = useCallback(\n    () => {\n        doSomething(a, b);\n    },\n    [a, b],\n);\n```\n\n【备注】 `useCallback(fn, deps)`  相当于  `useMemo(() => fn, deps)`。\n\n---\n\n##### 十一、useMemo\n\n把箭头函数 和 数组[a,b]，作为参数传递给  useMemo ，当数组  [a,b] 的数值发生改变后，会在渲染期间调用箭头函数。如果没有第二个参数[a,b]，那么每次渲染期间都会调用箭头函数。\n\n先编写在没有 `useMemo` 的情况下也可以执行的代码 —— 之后再在你的代码中添加 `useMemo`，以达到优化性能的目的。\n\n```js\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```\n\n【备注】 `useCallback(fn, deps)`  相当于  `useMemo(() => fn, deps)`。\n\n\n\n`React.memo` 等效于 `PureComponent`，但它只比较 props。（你也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。）\n\n`React.memo` 不比较 state，因为没有单一的 state 对象可供比较。但你也可以让子节点变为纯组件。\n\n---\n\n##### 十二、useImperativeHandle\n\n```js\n// 把自己暴露给父组件，供父组件操作访问自己内部。\nuseImperativeHandle(ref, createHandle, [deps])\n```\n\nuseImperativeHandle  应当与 forwardRef 一起使用：\n\n```js\n// input 把自己暴露给父组件，父组件就可以调用其 focus 方法。\nfunction FancyInput(props, ref) {\n    const inputRef = useRef();\n    useImperativeHandle(ref, () => ({\n        focus: () => {\n            inputRef.current.focus();\n        }\n    }));\n    return <input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);\n```\n\n```\n渲染 <FancyInput ref={inputRef} /> 的父组件可以调用 inputRef.current.focus()。\n```\n\n---\n\n##### 十、相关链接：\n\n- [React - Hook - 官方文档](https://zh-hans.reactjs.org/docs/hooks-intro.html)","url":"https://learn-anything.cn/react-hooks","published_at":"2021-10-05T00:49:57.000Z","tags":[{"name":"React","slug":"react"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"React的Hook让函数组件拥有class组件的特性！","slug":"react-hooks"}},
    "staticQueryHashes": ["63159454"]}