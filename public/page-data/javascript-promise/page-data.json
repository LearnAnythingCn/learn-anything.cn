{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/javascript-promise",
    "result": {"data":{"strapiArticles":{"id":"Articles_461","title":"JavaScript的异步操作（Promise/async/await）！","description":"Promise 是一个用于绑定异步操作与回调函数的对象，让代码更易读且更合理。async / await 建立在 Promise 之上，使异步代码更易于编写和阅读，他们是 ECMAScript 2017 JavaScript版本的新语法。","content":"##### 一、Promise 是什么？\n\nPromise 是一个用于绑定异步操作与回调函数的对象，让代码更易读且更合理。\n\n###### 1、简单实例\n\n```html\n<!-- index.html -->\n<!DOCTYPE html>\n<html lang='zh-CN'>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>异步调用</title>\n\n    <script>\n        let myFirstPromise = new Promise(function (resolve, reject) {\n            setTimeout(function () {\n                resolve(\"成功!\");\n                // reject(\"失败\");\n            }, 2500);\n        });\n\n        myFirstPromise\n            .then((successMessage) => {\n                console.log(successMessage);\n            })\n            .catch((errorMessage) => {\n                console.log(errorMessage);\n            });\n    </script>\n\n</head>\n\n<body>\n    <h1>打开 console 看输出结果！</h1>\n</body>\n\n</html>\n```\n\n---\n\n##### 二、语法说明\n\n###### 1、运行规则\n\n不同于传统的回调， then 关联的函数，会在异步操作完成后执行；如果有多个 then，那么也会依次调用，除非其中有调用 reject 跳转到 catch 。\n\n---\n\n###### 2、创建 Promise 对象\n\n通过 new 来创建 Promise 对象，当异步操作成功后调用 resolve 来改变 Promise对象的状态；失败后就调用 reject 。\n\n```js\nconst myFirstPromise = new Promise((resolve, reject) => {\n    // 做一些异步操作，最终会调用下面两者之一:\n    //\n    // resolve(someValue);\n    // 或\n    // reject(\"failure reason\");\n});\n```\n\n---\n\n###### 3、函数拥有 Promise 功能\n\n函数想要拥有 Promise 功能，只需让其返回一个 Promise对象 即可。\n\n```js\nfunction myAsyncFunction(url) {\n    return new Promise((resolve, reject) => {\n\t\t\t\tconst xhr = new XMLHttpRequest();\n        xhr.open(\"GET\", url);\n        xhr.onload = () => resolve(xhr.responseText);\n        xhr.onerror = () => reject(xhr.statusText);\n        xhr.send();\n    });\n};\n```\n\n---\n\n###### 4、不使用回调\n\n对 setTimeout 进行 Promise 封装，代码易读且包含异常处理等情况，步骤如下：\n\n```js\n// 1、过去是用方法\nsetTimeout(() => saySomething(\"10 seconds passed\"), 10000);\n\n// 2、用 Promise 封装\nconst wait = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// 3、以后用这种方式\nwait(10000).then(() => saySomething(\"10 seconds\")).catch(failureCallback);\n\n```\n\n---\n\n##### 三、静态函数\n\n###### 1、Promise.resolve()\n\n返回一个已处理的 Promise 对象。\n\n```js\nPromise.resolve(\"Success\").then(function(value) {\n  console.log(value); // \"Success\"\n}, function(value) {\n  // 不会被调用\n});\n```\n\n- [更多内容，看这里！](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)\n\n---\n\n###### 2、Promise.reject()\n\n返回一个带有拒绝原因的  `Promise`  对象。\n\n```js\nPromise.reject(new Error('fail')).then(function() {\n  // not called\n}, function(error) {\n  console.error(error); // Stacktrace\n});\n```\n\n- [更多内容，看这里！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)\n\n---\n\n###### 3、Promise.all()\n\n等待所有 Promise 对象执行完毕，如果其中任何一个产生 reject ，那么会立即返回。\n\n```\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([promise1, promise2, promise3]).then((values) => {\n  console.log(values);\n});\n// expected output: Array [3, 42, \"foo\"]\n```\n\n- [更多内容，看这！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n\n---\n\n###### 4、Promise.race()\n\n同时等待多个 Promise 对象，但只采用其中最先返回的 Promise 对象。\n\n```js\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 500, 'one');\n});\n\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'two');\n});\n\nPromise.race([promise1, promise2]).then((value) => {\n  console.log(value);\n  // Both resolve, but promise2 is faster\n});\n// expected output: \"two\"\n```\n\n- [更多内容，看这里！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\n\n---\n\n##### 四、async / await \n\n###### 1、概念说明\n\nasync / await 建立在 Promise 之上，使异步代码更易于编写和阅读，他们是 ECMAScript 2017 JavaScript版本的新语法。\n\n- async 怎么使用？\n\n  函数声明之前加上 async  关键字，就变成了异步函数了，返回值为promise。\n\n```js\nlet hello = async () => { return \"Hello\" };\nlet hello = async function() { return \"Hello\" };\nhello();\n```\n\n- await 怎么使用？\n\n  await 只有用于异步函数才起作用，基于 promise 的函数之前加上 await ，代码会在此行暂停，直到 promise 操作完成，当然其他代码可以继续执行。\n\n```js\nasync function hello() {\n  return greeting = await Promise.resolve(\"Hello\");\n};\n\nhello().then(alert);\n```\n\n- [详情，看这里！](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await)\n\n---\n\n###### 2、async / await 替代 Promise\n\n三种不同方式，实现相同的功能。\n\n- Promise 的写法\n\n```js\nfetch('coffee.jpg')\n    .then(response => response.blob())\n    .then(myBlob => {\n        let objectURL = URL.createObjectURL(myBlob);\n        let image = document.createElement('img');\n        image.src = objectURL;\n        document.body.appendChild(image);\n    })\n    .catch(e => {\n        console.log('There has been a problem with your fetch operation: ' + e.message);\n    });\n```\n\n- async / await 的写法\n\n```js\nasync function myFetch() {\n    let response = await fetch('coffee.jpg');\n    let myBlob = await response.blob();\n\n    let objectURL = URL.createObjectURL(myBlob);\n    let image = document.createElement('img');\n    image.src = objectURL;\n    document.body.appendChild(image);\n}\n\nmyFetch()\n    .catch(e => {\n        console.log('There has been a problem with your fetch operation: ' + e.message);\n    });\n```\n\n- 混合使用\n\n```js\nasync function myFetch() {\n    let response = await fetch('coffee.jpg');\n    return await response.blob();\n}\n\nmyFetch().then((blob) => {\n    let objectURL = URL.createObjectURL(blob);\n    let image = document.createElement('img');\n    image.src = objectURL;\n    document.body.appendChild(image);\n})\n    .catch((e) =>\n        console.log(e)\n    );\n```\n\n---\n\n###### 3、缺陷修正\n\n- 下面代码完成了同步，但增加了等待时间。\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Demonstration of slow async/await</title>\n</head>\n\n<body>\n    <script>\n        function timeoutPromise(interval) {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    resolve(\"done\");\n                }, interval);\n            });\n        };\n\n        async function timeTest() {\n            await timeoutPromise(3000);\n            await timeoutPromise(3000);\n            await timeoutPromise(3000);\n        }\n\n        let startTime = Date.now();\n        timeTest().then(() => {\n            let finishTime = Date.now();\n            let timeTaken = finishTime - startTime;\n            alert(\"Time taken in milliseconds: \" + timeTaken);\n        })\n    </script>\n</body>\n\n</html>\n```\n\n- 简单修改上面，即可提高性能\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Demonstration of fast async/await</title>\n</head>\n\n<body>\n    <script>\n        function timeoutPromise(interval) {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    resolve(\"done\");\n                }, interval);\n            });\n        };\n\n        async function timeTest() {\n            const timeoutPromise1 = timeoutPromise(3000);\n            const timeoutPromise2 = timeoutPromise(3000);\n            const timeoutPromise3 = timeoutPromise(3000);\n\n            await timeoutPromise1;\n            await timeoutPromise2;\n            await timeoutPromise3;\n        }\n\n        let startTime = Date.now();\n        timeTest().then(() => {\n            let finishTime = Date.now();\n            let timeTaken = finishTime - startTime;\n            alert(\"Time taken in milliseconds: \" + timeTaken);\n        })\n    </script>\n</body>\n\n</html>\n```\n\n---\n\n##### 五、其他异步操作\n\n###### 1、setTimeout\n\nsetTimeout ：在指定时间后执行一次；\n\n```html\n<!DOCTYPE html>\n<html lang=\"en-US\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Person greeter app</title>\n</head>\n\n<body>\n    <script>\n        let myGreeting = setTimeout(function () {\n            alert('Hello, Mr. Universe!');\n        }, 2000)\n\n        // 在超时前关闭计时器\n        // clearTimeout(myGreeting);\n    </script>\n</body>\n\n</html>\n```\n\n---\n\n###### 2、setInterval\n\n在指定的时间间隔，不停重复运行。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en-US\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Simple setInterval clock</title>\n    <style>\n        p {\n            font-family: sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <p class=\"clock\"></p>\n    <script>\n        function displayTime() {\n            let date = new Date();\n            let time = date.toLocaleTimeString();\n            document.querySelector('.clock').textContent = time;\n        }\n\n        const createClock = setInterval(displayTime, 1000);\n\n        // 关闭 Interval\n        // clearInterval(myInterval);\n    </script>\n</body>\n\n</html>\n```\n\n---\n\n##### 六、参考文档\n\n- [Promises 是什么？怎么用？](https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Promises)\n- [Promise  -  对象说明！](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n- [Using_promises  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises)\n- [async_function  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/async_function)\n- [await  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await)","url":"https://learn-anything.cn/javascript-promise","author":null,"published_at":"2021-12-17T05:42:30.000Z","tags":[{"name":"JavaScript","slug":"java-script"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"JavaScript的异步操作（Promise/async/await）！","slug":"javascript-promise"}},
    "staticQueryHashes": ["63159454"]}