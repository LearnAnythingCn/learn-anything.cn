{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/react-hoc",
    "result": {"data":{"strapiArticles":{"id":"Articles_95","title":"React的高阶组件怎么用？","description":"高阶组件是什么？高阶组件实例。高阶组件只组合，不破坏原组件。高阶组件要跟原有组件保持相似接口。HOC与调试、HOC与静态方法。","content":"##### 一、高阶组件是什么？\n\n高阶组件（HOC）是一个接收组件作为参数并返回新组件的函数。将多个组件的相同逻辑代码，抽象到HOC中，让组件更有结构化，更易于复用。HOC不破坏传入组件的特性，只通过组合形成新组件。HOC是纯函数，没有副作用。\n\n---\n\n##### 二、高阶组件实例\n\n接受了组件WrappedComponent，增加了订阅和数据刷新的操作。\n\n```js\n// 此函数接收一个组件...\nfunction withSubscription(WrappedComponent, selectData) {\n    // ...并返回另一个组件...\n    return class extends React.Component {\n        constructor(props) {\n            super(props);\n            this.handleChange = this.handleChange.bind(this);\n            this.state = {\n                data: selectData(DataSource, props)\n            };\n        }\n\n        componentDidMount() {\n            // ...负责订阅相关的操作...\n            DataSource.addChangeListener(this.handleChange);\n        }\n\n        componentWillUnmount() {\n            DataSource.removeChangeListener(this.handleChange);\n        }\n\n        handleChange() {\n            this.setState({\n                data: selectData(DataSource, this.props)\n            });\n        }\n\n        render() {\n            // ... 并使用新数据渲染被包装的组件!\n            // 请注意，我们可能还会传递其他属性\n            return <WrappedComponent data={this.state.data} {...this.props} />;\n        }\n    };\n}\n```\n\n想要增加订阅和数据刷新功能的组件，都可以使用withSubscription，调用如下：\n\n```JS\nconst CommentListWithSubscription = withSubscription(\n    CommentList,\n    (DataSource) => DataSource.getComments()\n);\n\nconst BlogPostWithSubscription = withSubscription(\n    BlogPost,\n    (DataSource, props) => DataSource.getBlogPost(props.id)\n);\n```\n\n---\n\n##### 三、只组合，不破坏原组件\n\n###### 1、错误：已经破坏\n\n```js\nfunction logProps(InputComponent) {\n    InputComponent.prototype.componentDidUpdate = function (prevProps) {\n        console.log('Current props: ', this.props);\n        console.log('Previous props: ', prevProps);\n    };\n    // 返回原始的 input 组件，暗示它已经被修改。\n    return InputComponent;\n}\n\n// 每次调用 logProps 时，增强组件都会有 log 输出。\nconst EnhancedComponent = logProps(InputComponent);\n```\n\n###### 2、正确：组合组件\n\n```js\nfunction logProps(WrappedComponent) {\n    return class extends React.Component {\n        componentDidUpdate(prevProps) {\n            console.log('Current props: ', this.props);\n            console.log('Previous props: ', prevProps);\n        }\n        render() {\n            // 将 input 组件包装在容器中，而不对其进行修改。Good!\n            return <WrappedComponent {...this.props} />;\n        }\n    }\n}\n```\n\n---\n\n##### 四、相似接口\n\nHOC 返回的组件与原组件应保持类似的接口。\n\n```js\nrender() {\n    const { extraProp, ...passThroughProps } = this.props;\n    const injectedProp = someStateOrInstanceMethod;\n    return (\n        <WrappedComponent\n            injectedProp={injectedProp}\n            {...passThroughProps}\n        />\n    );\n}\n```\n\n---\n\n##### 五、HOC方便调试\n\n用HOC包裹组件，加上HOC和组件的名字，调试时输出，方便准确定位bug位置。\n\n```js\nfunction withSubscription(WrappedComponent) {\n    class WithSubscription extends React.Component {/* ... */ }\n    WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n    return WithSubscription;\n}\n\nfunction getDisplayName(WrappedComponent) {\n    return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n\n##### 六、render()中禁止使用HOC\n\n在render方法中使用HOC，每一次HOC都会产生一个新组件，使得原来组件被卸载，再重新加载新组件，这不仅仅是性能问题 - 重新挂载组件会导致该组件及其所有子组件的状态丢失。\n\n```js\nrender() {\n    // 每次调用 render 函数都会创建一个新的 EnhancedComponent\n    // EnhancedComponent1 !== EnhancedComponent2\n    const EnhancedComponent = enhance(MyComponent);\n    // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！\n    return <EnhancedComponent />;\n}\n```\n\n---\n\n##### 七、静态方法与HOC\n\n用HOC包裹原组件，形成新组件，将不能访问原始组件的静态方法。\n\n```js\n// 定义静态函数\nWrappedComponent.staticMethod = function() {/*...*/}\n// 现在使用 HOC\nconst EnhancedComponent = enhance(WrappedComponent);\n\n// 增强组件没有 staticMethod\ntypeof EnhancedComponent.staticMethod === 'undefined' // true\n```\n\n可以通过下面这个方案解决：\n\n```js\n// 使用这种方式代替...\nMyComponent.someFunction = someFunction;\nexport default MyComponent;\n\n// ...单独导出该方法...\nexport { someFunction };\n\n// ...并在要使用的组件中，import 它们\nimport MyComponent, { someFunction } from './MyComponent.js';\n```\n\n---\n\n##### 八、参考链接：\n\n- [高阶组件 - 官方文档](https://zh-hans.reactjs.org/docs/higher-order-components.html)\n\n","url":"https://learn-anything.cn/react-hoc","published_at":"2021-10-07T01:59:00.000Z","tags":[{"name":"React","slug":"react"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"React的高阶组件怎么用？","slug":"react-hoc"}},
    "staticQueryHashes": ["63159454"]}