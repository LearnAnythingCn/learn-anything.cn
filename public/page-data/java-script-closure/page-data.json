{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/java-script-closure",
    "result": {"data":{"strapiArticles":{"id":"Articles_112","title":"JavaScript的闭包(closure)是什么？","description":"闭包与函数是什么关系？闭包怎么使用？闭包与私有化之间的关系？闭包的性能优化？闭包的数据封装与隐藏？","content":"##### 一、闭包是什么？\n\n闭包（closure）就是通过嵌套函数的方式，缓存嵌套函数及其执行环境，等待下一次调用。直观的说就是形成一个不销毁的栈环境。这样可以保护变量和方法，使其私有化。\n\n---\n\n###### 1、私有化变量\n\n```js\nfunction makeFunc() {\n    var name = \"Mozilla\";\n    function displayName() {\n        alert(name);\n    }\n    return displayName;\n}\n// 闭包隐藏了变量name，myFunc无法直接访问\nvar myFunc = makeFunc();\n\n// 只能通过执行闭包，来访问name\nmyFunc();\n```\n\n###### 2、缓存执行环境\n\n```js\nfunction makeAdder(x) {\n    return function (y) {\n        return x + y;\n    };\n}\n\n// 闭包的执行环境被缓存，也就是x的值和嵌套函数被缓存在add5\nvar add5 = makeAdder(5);\n\n// 调用执行闭包，输出结果：7\nconsole.log(add5(2));\n```\n\n---\n\n###### 3、数据封装与隐藏\n\nJavaScript中没有Java中private关键字，但可以用闭包来实现，做到对数据的隐藏和封装。\n\n```js\n// 成功的隐藏了 变量(privateCounter) 和 方法(changeBy)\nvar makeCounter = function () {\n    var privateCounter = 0;\n    function changeBy(val) {\n        privateCounter += val;\n    }\n    return {\n        increment: function () {\n            changeBy(1);\n        },\n        decrement: function () {\n            changeBy(-1);\n        },\n        value: function () {\n            return privateCounter;\n        }\n    }\n};\n\nvar Counter1 = makeCounter();\nvar Counter2 = makeCounter();\nconsole.log(Counter1.value()); /* logs 0 */\nCounter1.increment();\nCounter1.increment();\nconsole.log(Counter1.value()); /* logs 2 */\nCounter1.decrement();\nconsole.log(Counter1.value()); /* logs 1 */\nconsole.log(Counter2.value()); /* logs 0 */\n```\n\n---\n\n###### 4、性能优化\n\n如果不是特殊需求，在函数中创建函数是不明智的，因为闭包需要消耗更多CPU和内存资源，对脚本性能有负面影响。当创建新的对象时，应该在 prototype 中定义方法，而不是对象构造器。因为每一次创建对象，都要重新赋值构造器中的方法。\n\n```js\n// 比较糟糕的使用闭包的方式，\n// 因为每一次 new MyObject，都会重新赋值getName和getMessage\nfunction MyObject(name, message) {\n    this.name = name.toString();\n    this.message = message.toString();\n    this.getName = function () {\n        return this.name;\n    };\n\n    this.getMessage = function () {\n        return this.message;\n    };\n}\n```\n\n```js\n// 推荐使用这种方式，替代上面。\n// prototype 是所有MyObject对象共享的，无需重新赋值getName和getMessage\nfunction MyObject(name, message) {\n    this.name = name.toString();\n    this.message = message.toString();\n}\nMyObject.prototype.getName = function () {\n    return this.name;\n};\nMyObject.prototype.getMessage = function () {\n    return this.message;\n};\n```\n\n---\n\n##### 二、参考文档：\n\n- [Closures - 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)","url":"https://learn-anything.cn/java-script-closure","author":null,"published_at":"2021-10-11T05:10:19.000Z","tags":[{"name":"JavaScript","slug":"java-script"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"JavaScript的闭包(closure)是什么？","slug":"java-script-closure"}},
    "staticQueryHashes": ["63159454"]}