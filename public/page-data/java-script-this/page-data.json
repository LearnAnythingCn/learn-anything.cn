{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/java-script-this",
    "result": {"data":{"strapiArticles":{"id":"Articles_521","title":"详解JavaScript的this对象","description":"this 是当前运行环境的一个属性，指向最近的对象实例。","content":"##### 一、this 是什么？\n\nthis 是当前运行环境的特殊属性，指向最近的对象实例。\n\n---\n\n##### 二、怎么用？\n\n###### 1、全局\n\n```html\n<!DOCTYPE html>\n<html lang='zh-CN'>\n<head>\n    <meta charset=\"utf-8\">\n    <title>this</title>\n    <script>\n        // 全局环境下，等同于 window 对象\n        console.log(this === window); // true\n        a = 37;\n        console.log(window.a); // 37\n\n        this.b = \"MDN\";\n        console.log(window.b)  // \"MDN\"\n        console.log(b)         // \"MDN\"\n    </script>\n</head>\n<body>\n    <h1>打开 Console 看结果！</h1>\n</body>\n</html>\n```\n\n---\n\n###### 2、函数中this\n\n函数中的this指向调用他的实例对象。\n\n```js\nvar obj = {a: 'Custom'};\nvar a = 'Global';\nfunction whatsThis() {\n  return this.a;  \n}\n// 全局调用，this 指向 window 对象\nwhatsThis();          // Global\n// 强制实例对象obj转换为this\nwhatsThis.call(obj);  // Custom\nwhatsThis.apply(obj); // Custom\n```\n\n---\n\n###### 3、方法中this\n\n方法中的 this 是指向最近的对象实例。\n\n```js\nvar o = {\n    prop: 37,\n    f: function () {\n        return this.prop;\n    }\n};\nconsole.log(o.f()); // 37\n\no.b = { g: independent, prop: 42 };\n// g()方法中最近实例是b，实例o是再上一层实例\nconsole.log(o.b.g()); // 42\n```\n\n---\n\n###### 4、箭头函数中this\n\n箭头函数本身无法与 this 进行绑定，所以箭头函数中使用的this是指向上层作用域。call、bind、apply 对箭头函数中this无效。\n\n```js\n// 1、this 指向上层作用域\nvar globalObject = this;\nvar foo = (() => this);\nconsole.log(foo() === globalObject); // true\n\nvar obj = {foo: foo};\nconsole.log(obj.foo() === globalObject); // true\n\n// 2、call、bind 无法改变箭头函数中的 this\nconsole.log(foo.call(obj) === globalObject); // true\nfoo = foo.bind(obj);\nconsole.log(foo() === globalObject); // true\n```\n\n- 方法中使用含有this的箭头函数\n\n```js\nvar obj = {\n  bar: function() {\n    var x = (() => this);\n    return x;\n  }\n};\n// 1、调用方法，this指向对象实例\nvar fn = obj.bar();\nconsole.log(fn() === obj); // true\n// 2、引用方法，this不指向对象实例\nvar fn2 = obj.bar;\nconsole.log(fn2()() == window); // true\n```\n\n---\n\n###### 5、原型链上this\n\n原型链上的this也是指向最近对象实例。\n\n```js\nvar o = {\n  f: function() {\n    return this.a + this.b;\n  }\n};\n// 对象o是对象p的原型\nvar p = Object.create(o);\np.a = 1;\np.b = 4;\n\nconsole.log(p.f()); // 5\n```\n\n---\n\n###### 6、set、get中this\n\nset、get方法中的this也是指向最近对象实例。\n\n```js\nfunction sum() {\n  return this.a + this.b + this.c;\n}\n\nvar o = {\n  a: 1,\n  b: 2,\n  c: 3,\n  get average() {\n    return (this.a + this.b + this.c) / 3;\n  }\n};\n\nObject.defineProperty(o, 'sum', {\n    get: sum, enumerable: true, configurable: true});\n\nconsole.log(o.average, o.sum); // logs 2, 6\n```\n\n---\n\n###### 7、new与this\n\nnew 后面的构造函数，如果没有return语句，就会返回this；如果有，就用返回return语句的对象。\n\n```js\nfunction C(){\n  this.a = 37;\n}\nvar o = new C();\nconsole.log(o.a); // logs 37\n\nfunction C2(){\n  this.a = 37;\n  return {a:38};\n}\no = new C2();\nconsole.log(o.a); // logs 38\n```\n\n---\n\n###### 8、DOM中this\n\n如果this用在事件回调函数中，那么this指向触发事件的元素。\n\n```js\n// 被调用时，将关联的元素变成蓝色\nfunction bluify(e){\n  console.log(this === e.currentTarget); // 总是 true\n\n  // 当 currentTarget 和 target 是同一个对象时为 true\n  console.log(this === e.target);\n  this.style.backgroundColor = '#A5D9F3';\n}\n\n// 获取文档中的所有元素的列表\nvar elements = document.getElementsByTagName('*');\n\n// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色\nfor(var i=0 ; i<elements.length ; i++){\n  elements[i].addEventListener('click', bluify, false);\n}\n```\n\n---\n\n###### 9、类中this\n\n- 类方法中this指向调用它的对象实例。\n\n```js\nvar name = \"globalName\";\nclass Example{\n    name=\"className\";\n    fun(){\n        return this.name;\n    }\n}\n// 1、this指向实例对象\nlet exm = new Example();\nconsole.log(exm.fun());\n// 2、使用全局this作为实例对象\nlet funGlobal = Example.fun;\nconsole.log(exm.fun.call(this)); \n```\n\n- 使用bind方法，让类方法中this永远指向类的实例\n\n```js\nclass Car {\n    constructor() {\n        this.sayBye = this.sayBye.bind(this);\n    }\n    sayHi() {\n        console.log(`Hello from ${this.name}`);\n    }\n    sayBye() {\n        console.log(`Bye from ${this.name}`);\n    }\n    get name() {\n        return 'Ferrari';\n    }\n}\n\nclass Bird {\n    get name() {\n        return 'Tweety';\n    }\n}\n\nconst car = new Car();\nconst bird = new Bird();\n\n// 1、不同实例调用不同结果\ncar.sayHi(); // Hello from Ferrari\nbird.sayHi = car.sayHi;\nbird.sayHi(); // Hello from Tweety\n\n// 2、绑定this，结果不会改变\nbird.sayBye = car.sayBye;\nbird.sayBye();  // Bye from Ferrari\n```\n\n- 类中this 包含所有非静态方法，静态方法属于类本身属性。\n\n```js\nclass Example {\n    constructor() {\n        const proto = Object.getPrototypeOf(this);\n        console.log(Object.getOwnPropertyNames(proto));\n    }\n    first() { }\n    second() { }\n    static third() { }\n}\n\nnew Example(); // ['constructor', 'first', 'second']\n```\n\n---\n\n###### 10、bind()\n\nbind() 方法可以将函数的this 与 某个对象实例进行永久绑定，无需考虑函数的调用方式。已绑定对象无法再次绑定。\n\n```js\nfunction f(){\n  return this.a;\n}\n\nvar g = f.bind({a:\"azerty\"});\nconsole.log(g()); // azerty\n\n// 已绑定对象无法再次绑定。\nvar h = g.bind({a:'yoo'}); \nconsole.log(h()); // azerty\n\nvar o = {a:37, f:f, g:g, h:h};\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty\n```\n\n---\n\n##### 三、参考文档\n\n- [this  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)\n\n\n","url":"https://learn-anything.cn/java-script-this","published_at":"2021-12-23T15:24:45.000Z","tags":[{"name":"JavaScript","slug":"java-script"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"详解JavaScript的this对象","slug":"java-script-this"}},
    "staticQueryHashes": ["63159454"]}