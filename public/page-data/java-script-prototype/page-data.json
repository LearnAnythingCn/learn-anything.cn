{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/java-script-prototype",
    "result": {"data":{"strapiArticles":{"id":"Articles_111","title":"详解JavaScript的继承和原型链(prototype)","description":"上一层对象，就这样层层向上直至 `__proto__`  属性为 null ，最后这个对象就是 `Object` 。这种通过 `__proto__`  属性来链接对象的方法，称之为  **原型链** 。","content":"##### 一、原型链 是什么？\n\nJavaScript 的每个实例对象都有一个指向上一层对象的私有属性（称之为 `__proto__`） ，上一层对象又指向再上一层对象，就这样层层向上直至 `__proto__`  属性为 null ，最后这个对象就是 `Object` 。\n\n这种通过 `__proto__`  属性来链接对象的方法，称之为  **原型链** 。\n\n```js\nvar o = {a: 1};\n// 原型链如下:\n// o ---> Object.prototype ---> null\n\nvar a = [\"yo\", \"whadup\", \"?\"];\n// a ---> Array.prototype ---> Object.prototype ---> null\n\nfunction f(){\n  return 2;\n}\n// 原型链如下:\n// f ---> Function.prototype ---> Object.prototype ---> null\n\nfunction f() {\n  this.a = 1;\n  this.b = 2;\n}\nlet o = new f();\nf.prototype.b = 3;\nf.prototype.c = 4;\n// 原型链如下:\n// {a:1, b:2} ---> {b:3, c:4} ---> Object.prototype---> null\n```\n\n---\n\n##### 二、怎么使用？\n\n###### 1、Object.getPrototypeOf() 和 Object.setPrototypeOf()\n\nECMAScript 6 开始，可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问 `__proto__`  属性。\n\n```js\nfunction f() {\n  this.a = 1;\n  this.b = 2;\n}\n\nlet o = new f();\n// 1、为 f 的上层对象新增属性（推荐此种方式新增属性）\nf.prototype.b = 3;\nf.prototype.c = 4;\n\n// 2、查看上层对象属性\nconsole.log(Object.getPrototypeOf(o));\n\n// 3、此种方式设置上层对象的属性，会覆盖掉所有旧属性，慎用\nconsole.log(Object.setPrototypeOf(o, {e:5}));\n\n// 4、查看新的上层对象属性\nconsole.log(Object.getPrototypeOf(o));\n```\n\n---\n\n###### 2、prototype 与 Object.getPrototypeOf\n\n两者功能一致，都是用来访问原型属性，区别是：\n\n- prototype  用于类，而 Object.getPrototypeOf() 用于实例；\n- 共享：所有实例都可以访问，新增的 prototype 属性。\n\n```js\nfunction A(){\n  this.a = \"a\";\n}\n\nlet aIns = new A();\n\n// 1、一个用于类型、一个用于实例\nconsole.log(A.prototype);\nconsole.log(Object.getPrototypeOf(aIns));\n\nlet bIns = new A();\n// 2、共享：所有实例都可以访问 新增的原型属性\nA.prototype.b = \"b\";\nconsole.log(Object.getPrototypeOf(aIns).b);\nconsole.log(Object.getPrototypeOf(bIns).b);\n```\n\n```js\nvar o = new Foo();\n\n// 上面代码是让 JavaScript 执行了下面代码\n\nvar o = new Object();\no.__proto__ = Foo.prototype;\nFoo.call(o);\n```\n\n---\n\n###### 3、hasOwnProperty\n\n当访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻原型链上的所有对象，最后判断属性是否存在。hasOwnProperty  是 JavaScript 中唯一一个不会遍历原型链的方法。\n\n```js\nconst object1 = {};\nobject1.property1 = 42;\n\nconsole.log(object1.hasOwnProperty('property1'));\n// expected output: true\n\nconsole.log(object1.hasOwnProperty('toString'));\n// expected output: false\n```\n\n---\n\n###### 4、undefined\n\n没有赋值的属性是 undefined，所以无法通过 undefined 来判断属性是否存在。\n\n---\n\n##### 三、继承\n\n继承也是基于原型链的特性。ECMAScript6 引入 class 关键字来实现 类对象，但类对象也是基于原型链。\n\n###### 1、Object.create\n\n用 Object.create 来创建继承对象。\n\n```js\nvar a = {a: 1};\n// a ---> Object.prototype ---> null\n\nvar b = Object.create(a);\n// b ---> a ---> Object.prototype ---> null\nconsole.log(b.a); // 1 (继承而来)\n\nvar c = Object.create(b);\n// c ---> b ---> a ---> Object.prototype ---> null\n\nvar d = Object.create(null);\n// d ---> null\nconsole.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype\n```\n\n---\n\n###### 2、用 prototype 实现继承\n\n```js\n// 父对象：Person\nvar Person = function (name) {\n  this.name = name;\n  this.canTalk = true;\n};\nPerson.prototype.greet = function () {\n  if (this.canTalk) {\n    console.log('Hi, I am ' + this.name);\n  }\n};\n\n// 子对象：Employee\nvar Employee = function (name, title) {\n  Person.call(this, name);\n  this.title = title;\n};\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\nEmployee.prototype.greet = function () {\n  if (this.canTalk) {\n    console.log('Hi, I am ' + this.name + ', the ' + this.title);\n  }\n};\n\n// 子对象：Customer\nvar Customer = function (name) {\n  Person.call(this, name);\n};\nCustomer.prototype = Object.create(Person.prototype);\nCustomer.prototype.constructor = Customer;\n\n// 子对象：Mine\nvar Mime = function (name) {\n  Person.call(this, name);\n  this.canTalk = false;\n};\nMime.prototype = Object.create(Person.prototype);\nMime.prototype.constructor = Mime;\n\nvar bob = new Employee('Bob', 'Builder');\nvar joe = new Customer('Joe');\nvar mime = new Mime('Mime');\nbob.greet();\n// Hi, I am Bob, the Builder\njoe.greet();\n// Hi, I am Joe\nmime.greet();\n```\n\n---\n\n##### 四、其他\n\n###### 1、性能\n\n试图访问不存在的属性时会遍历整个原型链，在原型链上查找属性比较耗时，对性能有副作用。\n\n---\n\n###### 2、错误实践\n\n扩展内置原型会破坏封装，这不是好的解决方案，使用扩展内置原型的唯一理由是支持 JavaScript 引擎的新特性，如  `Array.forEach`。\n\n原生原型**不应该**被扩展，除非它是为了与新的 JavaScript 特性兼容。\n\n---\n\n##### 五、参考文档\n\n- [Inheritance_and_the_prototype_chain](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n\n\n","url":"https://learn-anything.cn/java-script-prototype","author":null,"published_at":"2021-10-11T05:07:37.000Z","tags":[{"name":"JavaScript","slug":"java-script"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"详解JavaScript的继承和原型链(prototype)","slug":"java-script-prototype"}},
    "staticQueryHashes": ["63159454"]}