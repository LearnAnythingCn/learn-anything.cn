{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/react-api",
    "result": {"data":{"strapiArticles":{"id":"Articles_116","title":"React的顶层API有哪些？","description":"创建元素、子元素操作、延迟加载等功能。createElement、React.Children、React.lazy、React.Fragment、React.createRef、React.forwardRef等。","content":"##### 一、简介\n\nReact库提供了如下API，可直接调用。\n\n---\n\n##### 二、创建元素\n\n###### 1、createElement()\n\n- 功能：创建 React 元素。\n\n  ```js\n  // 函数原型\n  React.createElement(\n      type,\n      [props],\n      [...children]\n  )\n  ```\n\n- 两种创建元素的方式：\n  - 使用JSX来创建元素，不需要调用createElement()，预处理器babel会处理\n\n    ```jsx\n    // 使用jsx创建元素和组件\n    class Hello extends React.Component {\n        render() {\n            return <div>Hello {this.props.toWhat}</div>;\n        }\n    }\n    \n    ReactDOM.render(\n        <Hello toWhat=\"World\" />,\n        document.getElementById('root')\n    );\n    ```\n\n  - 不使用JSX来创建元素，就需要调用createElement()\n\n    ```jsx\n    // 不使用jsx创建元素和组件\n    class Hello extends React.Component {\n        render() {\n            return React.createElement('div', null, `Hello ${this.props.toWhat}`);\n        }\n    }\n    \n    ReactDOM.render(\n        React.createElement(Hello, { toWhat: 'World' }, null),\n        document.getElementById('root')\n    );\n    ```\n\n---\n\n##### 三、元素操作API\n\n###### 1、cloneElement()\n\n- 功能：复制生成一个新元素。\n\n  ```js\n  // 函数原型\n  React.cloneElement(\n      element,\n      [config],\n      [...children]\n  )\n  // config ：含新的 props，key 或 ref\n  ```\n\n- 等同于jsx\n\n  ```jsx\n  React.cloneElement()\n  // 几乎等同于下面jsx写法\n  < element.type {...element.props } {...props }> { children }</element.type >\n  ```\n\n---\n\n###### 2、isValidElement()\n\n验证对象是否为 React 元素，返回值为 `true` 或 `false`。\n\n```js\nReact.isValidElement(object)\n```\n\n---\n\n##### 四、子元素操作API\n\nReact.Children功能：可以遍历访问子元素，同时可以访问到属性 `this.props.children` ，无法访问到的数据。\n\n###### 1、React.Children.map\n\n- 功能：遍历子元素，并返回一个数组。函数原型如下：\n\n  ```\n  React.Children.map(children, function)\n  ```\n\n- 使用实例：遍历并复制子元素\n\n  ```jsx\n  const Child = () => (\n      <div>child</div>\n  )\n  \n  class App extends React.Component {\n      render() {\n          const template1 = React.Children.map(this.props.children, (child) => {\n              return React.cloneElement(child);\n          });\n  \n          return template1;\n      }\n  }\n  ```\n\n###### 2、React.Children.forEach\n\n- 功能：与React.Children.map一样作用，区别是返回值不是数组。\n\n  ```js\n  React.Children.forEach(children, function)\n  ```\n\n###### 3、React.Children.count\n\n- 功能：返回 children 中的组件总数量，等同于通过 map 或 forEach 调用回调函数的次数。\n\n  ```js\n  React.Children.count(children)\n  ```\n\n###### 4、React.Children.only\n\n- 功能：验证 children 是否只有一个子节点(React元素)，如果有则返回它，否则此方法会抛出错误。\n\n  ```js\n  React.Children.only(children)\n  ```\n\n- 注意点：React.Children.only() 不接受 React.Children.map() 的返回值，因为它是一个数组而并不是 React 元素。\n\n---\n\n##### 五、组件相关API\n\n###### 1、React.Component\n\n- 功能：使用 [ES6 classes](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes) 方式定义 React 组件的基类：\n\n  ```jsx\n  class Greeting extends React.Component {\n      render() {\n          return <h1>Hello, {this.props.name}</h1>;\n      }\n  }\n  ```\n\n---\n\n###### 2、React.PureComponent\n\n- 功能：与React.Component 一样，都可以继承他们来实现组件。\n- 区别：React.PureComponent 实现了 shouldComponentUpdate()，而  React.Component  没有。React.PureComponent 只有在 prop 和 state 数据变化时，才进行组件渲染，可用于组件性能优化。\n\n- 两点注意：\n  - 确定  prop 和 state 数据是否变化时，会进行比较操作，这个比较操作只适合简单数据结构，不适用于复杂数据结构，请确保 prop 和state 对象不是复杂数据结构。\n\n  - 确保 子组件 也都继承 React.PureComponent。\n\n---\n\n###### 3、React.memo\n\n- 功能：是一个高阶组件，可以包裹其他组件来提高性能。\n\n- 原理：React.memo  会监控组件的 props 属性的变化，只有变化才重新渲染，否则跳过渲染操作。\n\n  ```jsx\n  const MyComponent = React.memo(function MyComponent(props) {\n      /* 使用 props 渲染 */\n  });\n  ```\n\n- 两点注意：\n\n  - 如果  React.memo 组件中使用了 useState、useContext，那么state、context 数值改变时，React.memo 组件也会重新渲染。\n\n  - React.memo 无法监控复杂数据结构props的变化，需要自定义比较函数来实现对复杂数据结构的监控。\n\n    ```js\n    function MyComponent(props) {\n        /* 使用 props 渲染 */\n    }\n    function areEqual(prevProps, nextProps) {\n        /*\n        如果把 nextProps 传入 render 方法的返回结果与\n        将 prevProps 传入 render 方法的返回结果一致则返回 true，\n        否则返回 false\n        */\n    }\n    export default React.memo(MyComponent, areEqual);\n    ```\n\n---\n\n##### 六、延迟加载\n\n渲染页面时，可以不加载未用到的组件。\n\n###### 1、React.lazy\n\n- 功能：延迟加载未用到的组件，依赖  `React.Suspense`\n\n  ```js\n  // 这个组件是动态加载的\n  const SomeComponent = React.lazy(() => import('./SomeComponent'));\n  ```\n\n- 注意：使用 `React.lazy` 的动态引入特性需要 JS 环境支持 Promise。在 IE11 及以下版本的浏览器中需要通过引入 polyfill 来使用该特性。\n\n---\n\n###### 2、React.Suspense\n\n- 名称：指定加载指示器（loading indicator）\n\n- 功能：配合上 `React.lazy`  完成延迟加载。\n\n  ```jsx\n  // 该组件是动态加载的\n  const OtherComponent = React.lazy(() => import('./OtherComponent'));\n  \n  function MyComponent() {\n      return (\n          // 显示 <Spinner> 组件直至 OtherComponent 加载完成\n          <React.Suspense fallback={<Spinner />}>\n              <div>\n                  <OtherComponent />\n              </div>\n          </React.Suspense>\n      );\n  }\n  ```\n\n---\n\n##### 七、其他API\n\n###### 1、React.Fragment\n\n- 功能：不额外创建 DOM 元素的情况下，让  `render()`  返回多个元素。使用详情，[看这里](https://learn-anything.cn/react-fragment)\n\n---\n\n###### 2、React.createRef\n\n- 功能：创建 ref  对象，指向组件，让其他组件方便访问其内部数据和方法。使用详情，[看这里](https://learn-anything.cn/react-refs)\n\n---\n\n###### 3、React.forwardRef\n\n- 功能：React.forwardRef 会创建一个React组件，新组件可以把传递进来的 ref 对象，转发给子元素。\n- 两种使用场景：`转发 refs 到 DOM 组件`  、`在高阶组件中转发 refs`。详情，[看这里](https://learn-anything.cn/react-refs)\n\n---\n\n##### 八、参考文档：\n\n- [React - API ](https://zh-hans.reactjs.org/docs/react-api.html)\n\n\n","url":"https://learn-anything.cn/react-api","published_at":"2021-10-14T09:34:22.000Z","tags":[{"name":"React","slug":"react"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"React的顶层API有哪些？","slug":"react-api"}},
    "staticQueryHashes": ["63159454"]}