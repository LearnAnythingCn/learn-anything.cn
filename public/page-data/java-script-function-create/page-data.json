{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/java-script-function-create",
    "result": {"data":{"strapiArticles":{"id":"Articles_509","title":"详解JavaScript的生成器函数(function*)","description":"用 `function *`  定义的函数称之为生成器函数，返回值是一个  Generator  对象，不能直接使用，需要通过调用 next()  方法来使用。","content":"##### 一、生成器函数是什么？\n\n用 `function *`  定义的函数称之为生成器函数，返回一个不能直接使用的  Generator  对象，但可以调用 next()  方法来使用。\n\n---\n\n###### 1、语法\n\n```js\n// 语法\nfunction* name([param[, param[, ... param]]]) { statements }\n```\n\n###### 2、简单实例\n\n```js\n// 实例\nfunction* generator(i) {\n\treturn  i+1;\n}\nconst gen = generator(10);\nconsole.log(gen.next());\n// 输出：{value: 11, done: true}\n```\n\n###### 3、不能作为构造函数\n\n```js\nfunction* f() {}\nvar obj = new f; // throws \"TypeError: f is not a constructor\"\n```\n\n---\n\n##### 二、其他特性\n\n###### 1、yield\n\n`yield`  关键字可以让生成器函数变成异步函数。yield 作用是暂停运行代码，直至下一次 next() 方法被调用。\n\n```js\nfunction* generator(i) {\n    yield i;\n    yield i + 10;\n}\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\n// 输出: 10\nconsole.log(gen.next().value);\n// 输出: 20\n```\n\n---\n\n###### 2、yield*\n\n`yield*`  表示移交代码执行权。\n\n```js\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\n\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);// 移交执行权\n  yield i + 10;\n}\n\nvar gen = generator(10);\n\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n\n###### 3、return\n\n`return` 表示无需等待，直接返回。\n\n```js\nfunction* yieldAndReturn() {\n  yield \"Y\";\n  return \"R\";//显式返回处，可以观察到 done 也立即变为了 true\n  yield \"unreachable\";// 不会被执行了\n}\n\nvar gen = yieldAndReturn()\nconsole.log(gen.next()); // { value: \"Y\", done: false }\nconsole.log(gen.next()); // { value: \"R\", done: true }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n---\n\n##### 三、更多使用场景\n\n###### 1、完整调用\n\n```js\nfunction* idMaker(){\n  var index = 0;\n  while(index<3)\n    yield index++;\n}\n\nvar gen = idMaker();\nconsole.log(gen.next().value); // 0\nconsole.log(gen.next().value); // 1\nconsole.log(gen.next().value); // 2\nconsole.log(gen.next().value); // undefined\n```\n\n###### 2、构造时传递参数\n\n```js\n// 可以接受参数\nfunction* idMaker(){\n    var index = arguments[0] || 0;\n    while(true)\n        yield index++;\n}\n\nvar gen = idMaker(5);\nconsole.log(gen.next().value); // 5\nconsole.log(gen.next().value); // 6\n```\n\n###### 3、运行时传递参数\n\n```js\n// 传递参数\nfunction *createIterator() {\n    let first = yield 1;\n    let second = yield first + 2; // 4 + 2\n                                  // first =4 是next(4)将参数赋给上一条的\n    yield second + 3;             // 5 + 3\n}\n\nlet iterator = createIterator();\n\nconsole.log(iterator.next());    // \"{ value: 1, done: false }\"\nconsole.log(iterator.next(4));   // \"{ value: 6, done: false }\"\nconsole.log(iterator.next(5));   // \"{ value: 8, done: false }\"\nconsole.log(iterator.next());    // \"{ value: undefined, done: true }\"\n```\n\n###### 4、遍历\n\n```js\n// 二维数组变成一维数组\nfunction* iterArr(arr) {            //迭代器返回一个迭代器对象\n  if (Array.isArray(arr)) {         // 内节点\n      for(let i=0; i < arr.length; i++) {\n          yield* iterArr(arr[i]);   // (*)递归\n      }\n  } else {                          // 离开\n      yield arr;\n  }\n}\n// 使用 for-of 遍历:\nvar arr = ['a', ['b', 'c'], ['d', 'e']];\nfor(var x of iterArr(arr)) {\n        console.log(x);               // a  b  c  d  e\n }\n\n// 或者直接将迭代器展开:\nvar arr = [ 'a', ['b',[ 'c', ['d', 'e']]]];\nvar gen = iterArr(arr);\narr = [...gen];                        // [\"a\", \"b\", \"c\", \"d\", \"e\"]\n```\n\n---\n\n##### 四、另外两种生成器函数\n\n###### 1、生成器函数表达式\n\n生成器函数表达式  可以省略函数名，而生成器函数不可以。\n\n```js\n// 语法\nfunction* [name]([param1[, param2[, ..., paramN]]]) {\n   statements\n}\n```\n\n```js\n// 实例\nconst foo = function*() {\n  yield 'a';\n  yield 'b';\n  yield 'c';\n};\n\nlet str = '';\nfor (const val of foo()) {\n  str = str + val;\n}\n\nconsole.log(str);\n// expected output: \"abc\"\n```\n\n---\n\n###### 2、GeneratorFunction\n\n- GeneratorFunction 并不是一个全局对象，只能通过 `Object.getPrototypeOf(function*(){}).constructor`  创建；\n\n- 在JavaScript中，生成器函数实际上都是  GeneratorFunction  的实例对象；\n\n- GeneratorFunction 创建的生成器函数 效率低于 `function*`  定义的生成器函数，且只能使用本地变量和全部变量。\n\n```js\n// 语法\nnew GeneratorFunction ([arg1[, arg2[, ...argN]],] functionBody)\n```\n\n```js\n// 实例\nvar GeneratorFunction = Object.getPrototypeOf(function*(){}).constructor\nvar g = new GeneratorFunction(\"a\", \"yield a * 2\");\nvar iterator = g(10);\nconsole.log(iterator.next().value); // 20\n```\n\n---\n\n##### 五、参考文档\n\n- [function*  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*)\n- [Generator  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator)\n- [function* expression  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function*) \n- [GeneratorFunction  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction) \n- [详解JavaScript的Generator对象](https://learn-anything.cn/java-script-generator)\n- [yield  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield)\n- [yield*  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*)\n\n\n","url":"https://learn-anything.cn/java-script-function-create","published_at":"2021-12-21T07:23:08.000Z","tags":[{"name":"JavaScript","slug":"java-script"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"详解JavaScript的生成器函数(function*)","slug":"java-script-function-create"}},
    "staticQueryHashes": ["63159454"]}