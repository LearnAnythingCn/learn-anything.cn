{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/java-script-weak-set",
    "result": {"data":{"strapiArticles":{"id":"Articles_518","title":"详解JavaScript的WeakSet数据结构","description":"WeakSet对象是一组对象的集合，对象不重复且不可枚举。WeakSet中的对象，如果不存在其他引用，那么该对象将可被垃圾回收，不用担心内存泄露。","content":"##### 一、WeakSet 是什么？\n\nWeakSet对象是一组对象的集合，对象不重复且不可枚举。WeakSet中的对象，如果不存在其他引用，那么该对象将可被垃圾回收，不用担心内存泄露。\n\n---\n\n##### 二、怎么用？\n\n###### 1、常用方法\n\n```js\nvar ws = new WeakSet();\nvar foo = {};\nvar bar = {};\n\nws.add(foo);\nws.add(bar);\n\nws.has(foo);    // true\nws.has(bar);   // true\n\nws.delete(foo); // 从set中删除 foo 对象\nws.has(foo);    // false, foo 对象已经被删除了\nws.has(bar);    // true, bar 依然存在\n```\n\n---\n\n##### 三、使用场景\n\n###### 1、检查循环引用\n\n递归调用自身的函数需要一种通过跟踪哪些对象已被处理，来应对循环数据结构的方法。\n\n```js\n// 对 传入的subject对象 内部存储的所有内容执行回调\nfunction execRecursively(fn, subject, _refs = null){\n\tif(!_refs)\n\t\t_refs = new WeakSet();\n\n\t// 避免无限递归\n\tif(_refs.has(subject))\n\t\treturn;\n\n\tfn(subject);\n\tif(\"object\" === typeof subject){\n\t\t_refs.add(subject);\n\t\tfor(let key in subject)\n\t\t\texecRecursively(fn, subject[key], _refs);\n\t}\n}\n\nconst foo = {\n\tfoo: \"Foo\",\n\tbar: {\n\t\tbar: \"Bar\"\n\t}\n};\n\nfoo.bar.baz = foo; // 循环引用!\nexecRecursively(obj => console.log(obj), foo);\n```\n\n---\n\n##### 四、参考文档\n\n- [WeakSet  -  MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)\n\n\n","url":"https://learn-anything.cn/java-script-weak-set","author":null,"published_at":"2021-12-22T15:07:34.000Z","tags":[{"name":"JavaScript","slug":"java-script"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"详解JavaScript的WeakSet数据结构","slug":"java-script-weak-set"}},
    "staticQueryHashes": ["63159454"]}