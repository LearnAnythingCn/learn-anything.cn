{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/react-reducer-hook",
    "result": {"data":{"strapiArticles":{"id":"Articles_118","title":"React的Reducer Hook让state有了状态！","description":"useReducer怎么用？初始化的方式有哪些？怎么提升性能？useContext与useReducer怎么解决回调烦恼？","content":"##### 一、解决什么问题？\n\nuseReducer  是 useState 的升级版本，对 setState 这个操作进行了拆分，可以根据不同类型，进行不同的逻辑计算，最后去改变 state 对象。\n\n###### 1、实例：useReducer 实现计数器组件\n\n```jsx\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'increment':\n            return { count: state.count + 1 };\n        case 'decrement':\n            return { count: state.count - 1 };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Counter() {\n    const [state, dispatch] = React.useReducer(reducer, initialState);\n    return (\n        <>\n            Count: {state.count}\n            <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n            <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n        </>\n    );\n}\n```\n\n---\n\n##### 二、useReducer 初始化方法\n\n###### 1、法一：使用第二个参数初始化\n\n```js\nconst [state, dispatch] = useReducer(\n    reducer,\n    { count: initialCount }\n);\n```\n\n###### 2、法二：惰性初始化\n\nuseReducer  需要一个初始值和初始函数，经过计算得到的值作为  useReduccer  的初始化数据。这样就把计算逻辑独立在 useReducer 外部，为将来对重置 state 的 action 做处理提供了便利。\n\n```jsx\nfunction init(initialCount) {\n    return { count: initialCount };\n}\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'increment':\n            return { count: state.count + 1 };\n        case 'decrement':\n            return { count: state.count - 1 };\n        case 'reset':\n            return init(action.payload);\n        default:\n            throw new Error();\n    }\n}\n\nfunction Counter({ initialCount }) {\n    const [state, dispatch] = useReducer(reducer, initialCount, init);\n    return (\n        <>\n            Count: {state.count}\n            <button\n                onClick={() => dispatch({ type: 'reset', payload: initialCount })}>\n                Reset\n            </button>\n            <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n            <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n        </>\n    );\n}\n```\n\n---\n\n##### 三、提升性能的说明\n\n如果  useReducer  返回的 state 相比于之前没有变化，React会自动跳过对组件的渲染操作。这里的比较操作是调用了js的  `Object.is()`  方法。\n\n---\n\n##### 四、解决层层回调的烦恼\n\n###### 1、useContext + useReducer\n\n顶层组件有个回调函数要传递下去，需要每一层都使用 props 进行设置，很繁琐，这里可以用 `useContext` +  `useReducer`  来解决。\n\nuseContext  负责传递执行函数，useReducer 负责对执行函数划分出不同状态，可供选择执行。\n\n```jsx\nconst TodosDispatch = React.createContext(null);\n\nfunction TodosApp() {\n    // 提示：`dispatch` 不会在重新渲染之间变化\n    const [todos, dispatch] = useReducer(todosReducer);\n\n    return (\n        <TodosDispatch.Provider value={dispatch}>\n            <DeepTree todos={todos} />\n        </TodosDispatch.Provider>\n    );\n}\n```\n\n```jsx\nfunction DeepChild(props) {\n    // 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。\n    const dispatch = useContext(TodosDispatch);\n\n    function handleClick() {\n        dispatch({ type: 'add', text: 'hello' });\n    }\n\n    return (\n        <button onClick={handleClick}>Add todo</button>\n    );\n}\n```\n\n---\n\n##### 五、参考链接：\n\n- [hooks-reference - usereducer](https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer)","url":"https://learn-anything.cn/react-reducer-hook","published_at":"2021-10-15T07:32:16.000Z","tags":[{"name":"React","slug":"react"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"React的Reducer Hook让state有了状态！","slug":"react-reducer-hook"}},
    "staticQueryHashes": ["63159454"]}