{
    "componentChunkName": "component---src-templates-article-article-detail-gen-js",
    "path": "/react-effect-hook",
    "result": {"data":{"strapiArticles":{"id":"Articles_114","title":"React的Effect Hook解决函数组件的性能问题和潜在bug！","description":"Effect Hook是啥？解决什么问题？怎么使用？有哪些潜在的性能问题？与useLayoutEffect有什么区别？","content":"##### 一、Effect Hook 是啥？\n\nHook 是以  `use` 开头的特殊函数，让 **函数组件**  拥有  **calss组件** 的某些特性。Effect Hook 就是指  `useEffect` 这个特殊函数，它让  **函数组件**  能在渲染完成后执行自定义操作。\n\n `useEffect` 中要谨慎使用  `useState `，因为它会触发组件渲染后，再次调用  useEffect，形成一个死循环。正确方式：用条件语句包裹 useState 方法，定义了退出条件，避开死循环。\n\n---\n\n##### 二、3种使用方式\n\n让组件只监控特定数据的变更，再进行渲染后的操作，忽略不必要的操作，很好的优化了组件性能。\n\n###### 1、useEffect(() => { })\n\n只有一个参数，每一次组件渲染完成后 且 在下一次渲染前 被调用。\n\n```jsx\n// 1、导入useEffect；\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n    const [count, setCount] = useState(0);\n\n    // 2、调用，箭头函数作为其唯一参数\n    useEffect(() => {\n        document.title = `You clicked ${count} times`;\n    });\n\n    return (\n        <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>\n                Click me\n            </button>\n        </div>\n    );\n}\n```\n\n---\n\n###### 2、useEffect(() => { }, [])\n\n有两个参数，第二个参数是空数组(`[]`) 。在组件首次加载渲染完成后被调用，且只被调用这一次。\n\n```js\nuseEffect(() => {\n    function doSomething() {\n        console.log('hello');\n    }\n\n    doSomething();\n}, []);\n```\n\n---\n\n###### 3、useEffect(() => { }, [count])\n\n有两个参数，第二个参数是数组。只有当数组里面的值改变时，`useEffect` 才会被调用。\n\n```js\n// 只有当 `props.source` 改变后才会调用 useEffect。\nuseEffect(\n    () => {\n        const subscription = props.source.subscribe();\n        return () => {\n            subscription.unsubscribe();\n        };\n    },\n    [props.source],\n);\n```\n\n---\n\n##### 三、清除机制\n\n`useEffect` 被调用时，执行了一些操作（譬如设定了一个定时器、访问了一些网络资源），在组件卸载时，必须做一些清除操作来防止内存泄露等问题。\n\n解决方案：只需要在  `useEffect`  中返回一个清除函数，React会在组件卸载之前调用清除函数。\n\n```js\n// 函数组件中实现：用户登录状态更新和清除\n// ChatAPI是假设的模块，它允许我们订阅好友的在线状态。\nimport React, { useState, useEffect } from 'react';\n\nfunction FriendStatus(props) {\n    const [isOnline, setIsOnline] = useState(null);\n\n    useEffect(() => {\n        function handleStatusChange(status) {\n            setIsOnline(status.isOnline);\n        }\n        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n\n        // 返回清除函数\n        return function cleanup() {\n            ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n        };\n    });\n\n    if (isOnline === null) {\n        return 'Loading...';\n    }\n    return isOnline ? 'Online' : 'Offline';\n}\n```\n\n---\n\n##### 四、依赖值频繁变化，怎么办？\n\n###### 1、问题：\n\nuseEffect 没有指定依赖，意味着 useEffect 只会运行一次，其内部获取到的 count 永远是初始值0，导致页面 中的`<h1>{count}</h1>` 值，永远是1。\n\n```js\nfunction Counter() {\n    const [count, setCount] = useState(0);\n\n    useEffect(() => {\n        const id = setInterval(() => {\n            setCount(count + 1);\n        }, 1000);\n        return () => clearInterval(id);\n    }, []);\n\n    return <h1>{count}</h1>;\n}\n```\n\n###### 2、不完美解决方案\n\n在  useEffect  中添加 count 依赖，这样每一次 useEffect 执行 setCount 带来count的变化，都会使得 useEffect 再次被调用，可以解决问题，但是这样会带来另一个问题，每一次执行 useEffect 都会清除计时器，再重新设置计时器，这不是我们想要的。\n\n```js\nfunction Counter() {\n    const [count, setCount] = useState(0);\n\n    useEffect(() => {\n        const id = setInterval(() => {\n            setCount(count + 1); // 这个 effect 依赖于 `count` state\n        }, 1000);\n        return () => clearInterval(id);\n    }, [count]); // 添加 count 依赖\n\n    return <h1>{count}</h1>;\n}\n```\n\n###### 3、最终解决方案\n\n采用 setState 的更新特性，让  setCount  自己去获取和更新 count，让  useEffect  完全脱离对 count 的依赖，实现最终理想效果。\n\n```js\nfunction Counter() {\n    const [count, setCount] = useState(0);\n\n    useEffect(() => {\n        const id = setInterval(() => {\n            setCount(c => c + 1);\n        }, 1000);\n        return () => clearInterval(id);\n    }, []);\n\n    return <h1>{count}</h1>;\n}\n```\n\n---\n\n##### 五、函数组件中实现class组件中的this\n\n###### 1、useRef + useEffect\n\n使用  `useRef`  和  `useEffect`  来实现，仅当你实在找不到更好办法的时候才这么做，因为依赖于变更会使得组件更难以预测。\n\n```js\nfunction Example(props) {\n    // 把最新的 props 保存在一个 ref 中\n    const latestProps = useRef(props);\n    useEffect(() => {\n        latestProps.current = props;\n    });\n\n    useEffect(() => {\n        function tick() {\n            // 在任何时候读取 props 都是最新的\n            console.log(latestProps.current);\n        }\n\n        const id = setInterval(tick, 1000);\n        return () => clearInterval(id);\n    }, []); // 这个 effect 只会执行一次\n}\n```\n\n---\n\n##### 六、依赖回调函数更新\n\n###### 1、useCallback + useEffect\n\n```js\nfunction ProductPage({ productId }) {\n    // ✅ 用 useCallback 包裹以避免随渲染发生改变\n    const fetchProduct = useCallback(() => {\n        // ... Does something with productId ...\n    }, [productId]); // ✅ useCallback 的所有依赖都被指定了\n\n    return <ProductDetails fetchProduct={fetchProduct} />;\n}\n\nfunction ProductDetails({ fetchProduct }) {\n    useEffect(() => {\n        fetchProduct();\n    }, [fetchProduct]); // ✅ useEffect 的所有依赖都被指定了\n    // ...\n}\n```\n\n---\n\n##### 七、useLayoutEffect\n\n`useEffect`  会在组件完全渲染完后被调用执行，此时执行的  useEffect  ，如果涉及到可见DOM变更，就可能给客户带来视觉上的跳跃感，此时可以考虑使用  `useLayoutEffect`，使用方式跟  `useEffect`  完全一样，只是被调用的时机不同。\n\n---\n\n##### 八、参考文档\n\n- [使用 Effect Hook](https://zh-hans.reactjs.org/docs/hooks-effect.html)\n\n- [性能优化](https://zh-hans.reactjs.org/docs/hooks-faq.html#performance-optimizations)\n\n\n","url":"https://learn-anything.cn/react-effect-hook","published_at":"2021-10-14T09:29:53.000Z","tags":[{"name":"React","slug":"react"}]},"site":{"siteMetadata":{"title":"收集优质资源","author":"@learn-anything.cn","description":"追求极简语言，说明事物因果！","email":"lh@learn-anything.cn"}}},"pageContext":{"title":"React的Effect Hook解决函数组件的性能问题和潜在bug！","slug":"react-effect-hook"}},
    "staticQueryHashes": ["63159454"]}